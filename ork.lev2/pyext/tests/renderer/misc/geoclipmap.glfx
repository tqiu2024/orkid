///////////////////////////////////////////////////////////////
// FxConfigs
///////////////////////////////////////////////////////////////
fxconfig fxcfg_default {
  import "orkshader://mathtools.i";
  import "orkshader://pbrtools.i";
  import "orkshader://envtools.i";
  import "orkshader://misctools.i";
}
///////////////////////////////////////////////////////////////

uniform_set ub_frgX {
  float Time;
  sampler3D MapVolTexA;
  sampler2D envmap;
  sampler2D refract_map;
  sampler2D depth_map;
  vec3 BaseColor;
  vec3 ColorB;
  vec3 ColorC;
  vec3 ColorD;
  float GroundColorPower;
  vec2 bufinvdim;
  float plightamp;

}
///////////////////////////////////////////////////////////////
libblock lib_ground_vtx_base : ub_frgX : lib_mmnoise {
  struct x_pos{
    vec4 true_wpos;
    vec4 new_pos;
    float signal;
    float radius;
  };
  
float wave_fn(vec3 center, vec3 pos, float timeval, float frq, float baseamp){
    frq = frq * 1.0;
    float radius = length(pos.xz - center.xz);
    float amp = clamp( pow(1 / radius,1.1), 0, 1);
    amp *= clamp(radius*0.3,0,1);
    return sin(radius * frq - timeval) * baseamp * 0.0254 * amp;
}

  x_pos vs_compute_position(vec4 pos) {
    x_pos _x;
    mat4 matO2W = inverse(v)*m;
    _x.true_wpos       = matO2W * pos;

    float speed = Time * 2.0;
    float baseamp = 150;
    vec3 wave_pos = _x.true_wpos.xyz*0.01;
    float radius = length(wave_pos.xz);

    /*float nze = octavenoise(MapVolTexA,
                      _x.true_wpos,
                      vec3(1,1,1), 
                      Time, 
                      8);*/

    float y = 0.0;
    //wave_fn(vec3(6,0,0), wave_pos, speed*1.0, 6.28*0.5, baseamp);
    //y += wave_fn(vec3(6,0,5), wave_pos, speed*1.5, 6.28*1.0, baseamp);
    //y += wave_fn(vec3(-6,0,-2), wave_pos, speed*2.0, 6.28*1.5, baseamp);
    //y += wave_fn(vec3(7,0,6), wave_pos, speed*2.5, 6.28*2.0, baseamp);
    //y += wave_fn(vec3(11,0,-6), wave_pos, speed*3.0, 6.28*2.5, baseamp);

    _x.signal = y;
    _x.new_pos = vec4(pos.x,pos.y+y,pos.z,1);
    _x.radius = radius;
    return _x;
  }
}
libblock lib_ground_vtx : ub_frgX : lib_ground_vtx_base {

  vec4 vs_common_mono(vec4 pos, vec3 nrm, vec3 bin) {
    vec4 cpos       = v * pos;

    x_pos _x = vs_compute_position(pos);


    vec3 wnormal    = normalize(mrot * nrm);
    vec3 wbitangent = normalize(mrot * bin); // technically binormal is a bitangent
    vec3 wtangent   = cross(wbitangent, wnormal);
    frg_wpos        = _x.true_wpos;


    float D = clamp(length(pos)*0.001,0,1); 

    vec3 C = mix(nrm,vec3(0.5),D);
    float intens = mix(0.5+_x.signal*0.3,0.5,D);

    frg_clr         = vec4(C*intens, 1); // TODO - split vs_rigid_gbuffer into vertexcolor vs identity
    frg_uv0         = uv0 * vec2(1, -1);
    frg_tbn         = mat3(wtangent, wbitangent, nrm);

    // compute eye to worldpos direction vector
    frg_camz = vec3(0,1,0);

    frg_camdist     = 1;
    return _x.new_pos;
  }

  void vs_common_stereo(vec4 pos, vec3 nrm, vec3 bin) {
    vec4 wpos       = m * pos;
    vec4 cpos_l       = (v_l*m) * pos;
    vec4 cpos_r       = (v_r*m) * pos;
    vec3 cpos = (cpos_l.xyz+cpos_r.xyz)*0.5;
    vec3 wnormal    = normalize(mrot * normal);
    vec3 wbitangent = normalize(mrot * binormal); // technically binormal is a bitangent
    vec3 wtangent   = cross(wbitangent, wnormal);
    frg_wpos        = wpos;
    //frg_wpos        = vec4(normal,1);
    frg_clr         = vec4(1, 1, 1, 1); // TODO - split vs_rigid_gbuffer into vertexcolor vs identity
    frg_uv0         = uv0 * vec2(1, -1);
    frg_tbn         = mat3(wtangent, wbitangent, normal);
    //frg_camz        = wnormal.xyz;

    // compute eye to worldpos direction vector
    frg_camz = normalize(cpos.xyz - wpos.xyz);
    frg_camdist     = -cpos.z;
  }

}

///////////////////////////////////////////////////////////////
vertex_shader vs_ground_mono //
  : iface_vgbuffer //
  : lib_ground_vtx { //
  // mv, mrot, m, mvp_l, mvp_r
  vec4 new_pos = vs_common_mono(position, normal, binormal);
  gl_Position                   = mvp * new_pos;
}
///////////////////////////////////////////////////////////////
vertex_interface iface_my_vdprepass : ub_vtx {
  inputs {
    vec4 position : POSITION;
  }
  outputs {
    float frg_depth;
  }
}
///////////////////////////////////////////////////////////////
vertex_shader vs_my_forward_depthprepass_mono //
  : iface_my_vdprepass //
  : lib_ground_vtx_base { //
  x_pos _x = vs_compute_position(position);

  vec4 new_pos = _x.new_pos;
  vec4 hpos    = mvp * new_pos;
  gl_Position  = hpos;
  frg_depth = (hpos.z) / (hpos.w-0.05);
}
///////////////////////////////////////////////////////////////
vertex_shader vs_ground_stereo //
  : iface_vgbuffer_stereo //
  : lib_ground_vtx //
  : extension(GL_NV_stereo_view_rendering) //
  : extension(GL_NV_viewport_array2) { //
  // mv, mrot, m, mvp_l, mvp_r
  vs_common_stereo(position, normal, binormal);
  gl_Position                   = mvp_l * position;
  gl_SecondaryPositionNV        = mvp_r * position;
  gl_Layer                      = 0;
  gl_ViewportMask[0]            = 1;
  gl_SecondaryViewportMaskNV[0] = 2;
}
///////////////////////////////////////////////////////////////
fragment_shader ps_fwd_ground_mono
  : iface_forward
  : lib_fwd 
  : ub_frgX {
    vec2 uv =  gl_FragCoord.xy * bufinvdim;
    float depth = textureLod(depth_map,uv,0).r;
    float ndc_z = depth*2.0 - 1.0;
    float ndc_x = (uv.x * 2.0 - 1.0);
    float ndc_y = (uv.y * 2.0 - 1.0);
    vec4 clip = vec4(ndc_x,ndc_y,ndc_z,1.0);
    vec4 wld = inverse(vp) * clip;
    wld /= wld.w;
    float D = clamp( length(frg_wpos.xyz-wld.xyz)*0.01, 0, 1 );
    D = pow(D, 0.1125);

    out_color = vec4(frg_clr.xyz,D);
}
///////////////////////////////////////////////////////////////
fragment_shader ps_fwd_ground_stereo
  : iface_forward
  : ub_frgX {
    out_color = frg_wpos;
}
///////////////////////////////////////////////////////////////
technique FWD_DEPTHPREPASS_RI_NI_MO {
	fxconfig=fxcfg_default;
	vf_pass={vs_my_forward_depthprepass_mono,ps_forward_depthprepass,sb_default}
}
///////////////////////////////////////////////////////////////
technique FWD_CT_NM_RI_NI_MO {
  fxconfig=fxcfg_default;
  vf_pass={vs_ground_mono,ps_fwd_ground_mono,sb_default}
}
///////////////////////////////////////////////////////////////
technique FWD_CT_NM_RI_NI_ST {
  fxconfig=fxcfg_default;
  vf_pass={vs_ground_stereo,ps_fwd_ground_stereo,sb_default}
}