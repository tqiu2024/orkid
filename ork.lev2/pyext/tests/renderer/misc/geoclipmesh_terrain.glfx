///////////////////////////////////////////////////////////////
// FxConfigs
///////////////////////////////////////////////////////////////
fxconfig fxcfg_default {
import "orkshader://mathtools.i";
import "orkshader://pbrtools.i";
import "orkshader://envtools.i";
import "orkshader://misctools.i";
}
///////////////////////////////////////////////////////////////
uniform_set ub_frgX {
  float Time;
}
///////////////////////////////////////////////////////////////
vertex_interface vif_my_depthprepass : ub_vtx {
  inputs {
    vec4 position : POSITION;
  }
  outputs {
    float frg_depth;
  }
}
///////////////////////////////////////////////////////////////
vertex_interface vif_terrain : ub_vtx {
  inputs {
    vec4 position : POSITION;
    vec3 normal : NORMAL;
    vec3 binormal : BINORMAL;
    vec4 vtxcolor : COLOR0;
    vec2 uv0 : TEXCOORD0;
  }
  outputs {
    vec4 frg_wpos;
    //mat3 frg_tbn;
    vec3 frg_mesh_bary;
    vec3 frg_displacement;
  }
}
///////////////////////////////////////////////////////////////
fragment_interface fif_terrain : ub_frg_fwd : ub_frg_fwd_lighting {
  inputs {
    vec4 frg_wpos;
    //mat3 frg_tbn;
    vec3 frg_mesh_bary;
    vec3 frg_displacement;
  }
  outputs {
    layout(location = 0) vec4 out_color;
  }
}
///////////////////////////////////////////////////////////////
libblock lib_ground_vtx_base : ub_frgX : lib_mmnoise {
  struct TerrainData {
    vec3 _meshPos;
    vec4 _baseWorldPos;
    vec4 _terrainPos;
    vec3 displacement;
    float radius;
  };


  TerrainData vs_compute_position(vec3 pos) {
    TerrainData TD;
    TD._meshPos = pos;
    mat4 matO2W  = inverse(v) * m;
    vec4 base_pos = matO2W * vec4(pos, 1);
    TD._baseWorldPos = base_pos;

    float speed   = Time * 1.65;
    float baseamp = 5;
    float radius  = length(base_pos.xz);

    float displace = baseamp * sin(radius*0.1);
    vec4 displaced = base_pos + vec4(0,displace,0,0);
    TD.displacement  = vec3(0,displace,0);
    TD._terrainPos = displaced;
    TD.radius  = radius;
    return TD;
  }
}
libblock lib_ground_vtx : ub_frgX : lib_ground_vtx_base {

  vec4 vs_common_mono(vec4 pos, vec3 nrm, vec3 bin) {
    vec4 cpos = v * pos;

    TerrainData TD = vs_compute_position(pos.xyz);
    frg_wpos   = TD._terrainPos;

    float D = clamp(length(pos) * 0.0001, 0, 1);
    vec3 C       = mix(nrm, vec3(0.5), D);
    float intens = mix(0.5 + TD.displacement.y * 0.1, 0.5, D);

    vec3 wnormal    = normalize(mrot * nrm);

    //frg_tbn[0] = TD._baseWorldPos.xyz;
    //frg_tbn[1] = binormal.xyz;
    frg_mesh_bary = wnormal.xyz;

    // compute eye to worldpos direction vector
    frg_displacement = TD.displacement; 
    return TD._terrainPos;
  }

  void vs_common_stereo(vec4 pos, vec3 nrm, vec3 bin) {
  }
}

///////////////////////////////////////////////////////////////
vertex_shader vs_ground_mono //
    : vif_terrain         //
    : lib_ground_vtx {       //
  vec4 _terrainPos = vs_common_mono(position, normal, binormal);
  gl_Position  = mvp * _terrainPos;
}
///////////////////////////////////////////////////////////////
vertex_shader vs_my_forward_depthprepass_mono //
    : vif_my_depthprepass                      //
    : lib_ground_vtx_base {                   //
  x_pos _x = vs_compute_position(position);

  vec4 _terrainPos = _x._terrainPos;
  vec4 hpos    = mvp * _terrainPos;
  gl_Position  = hpos;
  frg_depth    = (hpos.z) / (hpos.w - 0.05);
}
///////////////////////////////////////////////////////////////
vertex_shader vs_ground_stereo               //
    : vif_terrain_stereo                  //
    : lib_ground_vtx                         //
    : extension(GL_NV_stereo_view_rendering) //
    : extension(GL_NV_viewport_array2) {     //
  vs_common_stereo(position, normal, binormal);
  gl_Position                   = mvp_l * position;
  gl_SecondaryPositionNV        = mvp_r * position;
  gl_Layer                      = 0;
  gl_ViewportMask[0]            = 1;
  gl_SecondaryViewportMaskNV[0] = 2;
}
///////////////////////////////////////////////////////////////
fragment_shader ps_fwd_ground_mono : fif_terrain : ub_frgX {

  vec3 bary = frg_mesh_bary;

  vec3 dPdu   = dFdx(frg_wpos.xyz);
  vec3 dPdv   = dFdy(frg_wpos.xyz);
  vec3 normal = cross(dPdu, dPdv); // Corrected normal calculation
  normal      = normalize(normal);

  //out_color = vec4(mod(frg_wpos.xyz,10)*0.1, 1);
  out_color = vec4(bary, 1);
}
///////////////////////////////////////////////////////////////
fragment_shader ps_fwd_ground_stereo : fif_terrain : ub_frgX {
  out_color = frg_wpos;
}
///////////////////////////////////////////////////////////////
technique FWD_DEPTHPREPASS_RI_NI_MO {
  fxconfig = fxcfg_default;
  vf_pass  = { vs_my_forward_depthprepass_mono, ps_forward_depthprepass, sb_default }
}
///////////////////////////////////////////////////////////////
technique FWD_CT_NM_RI_NI_MO {
  fxconfig = fxcfg_default;
  vf_pass  = { vs_ground_mono, ps_fwd_ground_mono, sb_default }
}
///////////////////////////////////////////////////////////////
technique FWD_CT_NM_RI_NI_ST {
  fxconfig = fxcfg_default;
  vf_pass  = { vs_ground_stereo, ps_fwd_ground_stereo, sb_default }
}