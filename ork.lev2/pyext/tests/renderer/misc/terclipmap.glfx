///////////////////////////////////////////////////////////////
// FxConfigs
///////////////////////////////////////////////////////////////
fxconfig fxcfg_default {
  import "orkshader://mathtools.i";
  import "orkshader://pbrtools.i";
  import "orkshader://envtools.i";
}
///////////////////////////////////////////////////////////////
uniform_set ub_frgX {
  float Time;
  sampler3D MapVolTexA;
  sampler2D envmap;
  sampler2D refract_map;
  sampler2D depth_map;
  vec3 BaseColor;
  vec3 ColorB;
  vec3 ColorC;
  vec3 ColorD;
  float GroundColorPower;
  vec2 bufinvdim;
  float plightamp;

}
///////////////////////////////////////////////////////////////
libblock lib_ground_vtx {

  void vs_common_mono(vec4 pos, vec3 nrm, vec3 bin) {
    vec4 cpos       = v * pos;
    vec4 wpos       = m * pos;
    vec3 wnormal    = normalize(mrot * normal);
    vec3 wbitangent = normalize(mrot * binormal); // technically binormal is a bitangent
    vec3 wtangent   = cross(wbitangent, wnormal);
    frg_wpos        = vec4(normal,1);
    frg_clr         = vec4(1, 1, 1, 1); // TODO - split vs_rigid_gbuffer into vertexcolor vs identity
    frg_uv0         = uv0 * vec2(1, -1);
    frg_tbn         = mat3(wtangent, wbitangent, normal);

    // compute eye to worldpos direction vector
    frg_camz = vec3(0,1,0);

    frg_camdist     = -cpos.z;
  }

  void vs_common_stereo(vec4 pos, vec3 nrm, vec3 bin) {
    vec4 wpos       = m * pos;
    vec4 cpos_l       = (v_l*m) * pos;
    vec4 cpos_r       = (v_r*m) * pos;
    vec3 cpos = (cpos_l.xyz+cpos_r.xyz)*0.5;
    vec3 wnormal    = normalize(mrot * normal);
    vec3 wbitangent = normalize(mrot * binormal); // technically binormal is a bitangent
    vec3 wtangent   = cross(wbitangent, wnormal);
    frg_wpos        = vec4(normal,1);
    frg_clr         = vec4(1, 1, 1, 1); // TODO - split vs_rigid_gbuffer into vertexcolor vs identity
    frg_uv0         = uv0 * vec2(1, -1);
    frg_tbn         = mat3(wtangent, wbitangent, normal);
    //frg_camz        = wnormal.xyz;

    // compute eye to worldpos direction vector
    frg_camz = normalize(cpos.xyz - wpos.xyz);
    frg_camdist     = -cpos.z;
  }

}

///////////////////////////////////////////////////////////////
vertex_shader vs_ground_mono //
  : iface_vgbuffer //
  : lib_ground_vtx { //
  // mv, mrot, m, mvp_l, mvp_r
  vs_common_mono(position, normal, binormal);
  gl_Position                   = mvp * position;
}
///////////////////////////////////////////////////////////////
vertex_shader vs_ground_stereo //
  : iface_vgbuffer_stereo //
  : lib_ground_vtx //
  : extension(GL_NV_stereo_view_rendering) //
  : extension(GL_NV_viewport_array2) { //
  // mv, mrot, m, mvp_l, mvp_r
  vs_common_stereo(position, normal, binormal);
  gl_Position                   = mvp_l * position;
  gl_SecondaryPositionNV        = mvp_r * position;
  gl_Layer                      = 0;
  gl_ViewportMask[0]            = 1;
  gl_SecondaryViewportMaskNV[0] = 2;
}
///////////////////////////////////////////////////////////////
fragment_shader ps_fwd_ground_mono
  : iface_forward
  : lib_fwd 
  : ub_frgX {
    out_color = frg_wpos;
}
///////////////////////////////////////////////////////////////
fragment_shader ps_fwd_ground_stereo
  : iface_forward
  : ub_frgX {
    out_color = frg_wpos;
}
///////////////////////////////////////////////////////////////
technique FWD_DEPTHPREPASS_RI_NI_MO {
	fxconfig=fxcfg_default;
	vf_pass={vs_forward_depthprepass_mono,ps_forward_depthprepass,sb_default}
}
///////////////////////////////////////////////////////////////
technique FWD_CT_NM_RI_NI_MO {
  fxconfig=fxcfg_default;
  vf_pass={vs_ground_mono,ps_fwd_ground_mono,sb_default}
}
///////////////////////////////////////////////////////////////
technique FWD_CT_NM_RI_NI_ST {
  fxconfig=fxcfg_default;
  vf_pass={vs_ground_stereo,ps_fwd_ground_stereo,sb_default}
}