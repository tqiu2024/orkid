///////////////////////////////////////////////////////////////
// FxConfigs
///////////////////////////////////////////////////////////////
fxconfig fxcfg_default {
  import "orkshader://mathtools.i";
  import "orkshader://pbrtools.i";
  import "orkshader://envtools.i";
}
///////////////////////////////////////////////////////////////
uniform_set ub_frgX {
  float Time;
  sampler3D MapVolTexA;
  sampler2D envmap;
  vec3 ColorA;
  vec3 ColorB;
  vec3 ColorC;
  vec3 ColorD;
  float GroundColorPower;

}
///////////////////////////////////////////////////////////////
libblock lib_ground_vtx {

  void vs_common_mono(vec4 pos, vec3 nrm, vec3 bin) {
    vec4 cpos       = v * pos;
    vec4 wpos       = m * pos;
    vec3 wnormal    = normalize(mrot * normal);
    vec3 wbitangent = normalize(mrot * binormal); // technically binormal is a bitangent
    vec3 wtangent   = cross(wbitangent, wnormal);
    frg_wpos        = wpos;
    frg_clr         = vec4(1, 1, 1, 1); // TODO - split vs_rigid_gbuffer into vertexcolor vs identity
    frg_uv0         = uv0 * vec2(1, -1);
    frg_tbn         = mat3(wtangent, wbitangent, wnormal);

    // compute eye to worldpos direction vector
    frg_camz = vec3(0,1,0);

    frg_camdist     = -cpos.z;
  }

  void vs_common_stereo(vec4 pos, vec3 nrm, vec3 bin) {
    vec4 wpos       = m * pos;
    vec4 cpos_l       = (v_l*m) * pos;
    vec4 cpos_r       = (v_r*m) * pos;
    vec3 cpos = (cpos_l.xyz+cpos_r.xyz)*0.5;
    vec3 wnormal    = normalize(mrot * normal);
    vec3 wbitangent = normalize(mrot * binormal); // technically binormal is a bitangent
    vec3 wtangent   = cross(wbitangent, wnormal);
    frg_wpos        = m * pos;
    frg_clr         = vec4(1, 1, 1, 1); // TODO - split vs_rigid_gbuffer into vertexcolor vs identity
    frg_uv0         = uv0 * vec2(1, -1);
    frg_tbn         = mat3(wtangent, wbitangent, wnormal);
    //frg_camz        = wnormal.xyz;

    // compute eye to worldpos direction vector
    frg_camz = normalize(cpos.xyz - wpos.xyz);
    frg_camdist     = -cpos.z;
  }

}
///////////////////////////////////////////////////////////////
libblock lib_ground_frg
 : ub_frgX 
 : lib_math
 : lib_envmapping {

float wave_fn(vec3 center, vec3 pos, float timeval, float frq, float baseamp){
    float radius = length(pos.xz - center.xz);
    float amp = clamp( pow(1 / radius,0.5), 0, 1);
    return sin(radius * frq - timeval) * baseamp * 0.0254 * amp;
}

vec4 gen_ground_(vec2 UV, vec3 eye_pos) {
    float waveHeight = 0.0254*0.125; // 1 inch in meters

    vec3 wpos       = frg_wpos.xyz;

    vec3 eye_dir = normalize(wpos-eye_pos);

    vec3 pos = wpos;
    // World space position

    float speed = Time * 2.0;
    float baseamp = 5;

    vec3 wave_pos = wpos*0.01;

    pos.y += wave_fn(vec3(0,0,0), wave_pos, speed*1.0, 6.28*0.5, baseamp);
    pos.y += wave_fn(vec3(1,0,0), wave_pos, speed*1.5, 6.28*1.0, baseamp);
    pos.y += wave_fn(vec3(-1,0,0), wave_pos, speed*2.0, 6.28*1.5, baseamp);
    pos.y += wave_fn(vec3(0,0,1), wave_pos, speed*2.5, 6.28*2.0, baseamp);
    pos.y += wave_fn(vec3(0,0,-1), wave_pos, speed*3.0, 6.28*2.5, baseamp);

    // Create normal from screen space derivatives
    vec3 dPdu = dFdx(pos);
    vec3 dPdv = dFdy(pos);
    vec3 normal = normalize(cross(dPdu, dPdv)); // Corrected normal calculation
    //normal = vec3(0,1,0);

    vec3 R = normalize(reflect(eye_dir, normal));
    vec3 S = env_equirectangularFlipV(R*vec3(-1,-1,-1),MapSpecularEnv,0);
    vec3 D = env_equirectangular(R*vec3(-1,-1,-1),MapDiffuseEnv,0);
    vec3 L = mix(S,D,pow(pos.y,1));
    vec3 color = vec3(0,.02,.15);
    L = (L*0.5+color)*0.5;
    return vec4(L, 1);
}
}

libblock lib_ground_mono {

  vec4 gen_ground_mono(vec2 UV) {
    return gen_ground_(UV,EyePostion);
  }

}

libblock lib_ground_stereo {

  vec4 gen_ground_stereo(vec2 UV) {
    vec3 eyepos = bool(gl_ViewportIndex) ? EyePostionR : EyePostionL;
    return gen_ground_(UV,eyepos);
  }

}

///////////////////////////////////////////////////////////////
vertex_shader vs_ground_mono //
  : iface_vgbuffer //
  : lib_ground_vtx { //
  // mv, mrot, m, mvp_l, mvp_r
  vs_common_mono(position, normal, binormal);
  gl_Position                   = mvp * position;
}
///////////////////////////////////////////////////////////////
vertex_shader vs_ground_stereo //
  : iface_vgbuffer_stereo //
  : lib_ground_vtx //
  : extension(GL_NV_stereo_view_rendering) //
  : extension(GL_NV_viewport_array2) { //
  // mv, mrot, m, mvp_l, mvp_r
  vs_common_stereo(position, normal, binormal);
  gl_Position                   = mvp_l * position;
  gl_SecondaryPositionNV        = mvp_r * position;
  gl_Layer                      = 0;
  gl_ViewportMask[0]            = 1;
  gl_SecondaryViewportMaskNV[0] = 2;
}
///////////////////////////////////////////////////////////////
fragment_shader ps_fwd_ground_mono
  : iface_forward
  : lib_ground_frg
  : lib_ground_mono
  : ub_frgX {
    out_color = gen_ground_mono(frg_uv0);
}
///////////////////////////////////////////////////////////////
fragment_shader ps_fwd_ground_stereo
  : iface_forward
  : lib_ground_frg
  : lib_ground_stereo
  : ub_frgX {
    out_color = gen_ground_stereo(frg_uv0);
}
///////////////////////////////////////////////////////////////
technique FWD_DEPTHPREPASS_RI_NI_MO {
	fxconfig=fxcfg_default;
	vf_pass={vs_forward_depthprepass_mono,ps_forward_depthprepass,sb_default}
}
///////////////////////////////////////////////////////////////
technique FWD_CT_NM_RI_NI_MO {
  fxconfig=fxcfg_default;
  vf_pass={vs_ground_mono,ps_fwd_ground_mono,sb_default}
}
///////////////////////////////////////////////////////////////
technique FWD_CT_NM_RI_NI_ST {
  fxconfig=fxcfg_default;
  vf_pass={vs_ground_stereo,ps_fwd_ground_stereo,sb_default}
}